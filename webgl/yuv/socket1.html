<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'>
    <meta http-equiv='x-ua-compatible' content='ie=edge'>
    <title>webgl yuv</title>
    <style>
      #app {
        display: flex;
        flex-flow: column;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div id='app'>
      <button type='button' class='btn'>next frame</button>
      <img src='' alt='' class='img'>
    </div>
    <script src='../lib/webgl-utils.js'></script>
    <script src='../lib/webgl-debug.js'></script>
    <script src='../lib/cuon-utils.js'></script>
    <script>
      // 顶点着色器
      var VSHADER_SOURCE = `
        attribute vec4 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main () {
          gl_Position = a_position;
          v_texCoord = a_texCoord;
        }
      `
      // 片元着色器
      var FSHADER_SOURCE = `
        precision mediump float;
        uniform sampler2D Ytex, Utex, Vtex;
        varying vec2 v_texCoord;
        void main(void) {
          float r, g, b, y, u, v;
          y = texture2D(Ytex, v_texCoord).r;
          u = texture2D(Utex, v_texCoord).r;
          v = texture2D(Vtex, v_texCoord).r;
          y = 1.1643 * (y - 0.0625);
          u = u - 0.5;
          v = v - 0.5;
          r = y + 1.5958 * v;
          g = y - 0.39173 * u - 0.81290 * v;
          b = y + 2.017 * u;
          gl_FragColor = vec4(r, g, b, 1.0);
        }
      `
      var yTexture, uTexture, vTexture
      var ctx = {}

      function initCanvas (options) {
        // 初始化 webgl
        var canvas = window.canvas = document.createElement('canvas')
        canvas.width = ctx.width = options.width
        canvas.height = ctx.height = options.height
        document.body.appendChild(canvas)
        var gl = window.gl = getWebGLContext(canvas)
        // 顶点坐标和纹理坐标
        initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)
        initTextures()
      }

      function initTextures () {
        // yuv texture
        yTexture = createTexture(gl.TEXTURE0)
        uTexture = createTexture(gl.TEXTURE1)
        vTexture = createTexture(gl.TEXTURE2)
        // pass texture to sampler
        var ySampler = gl.getUniformLocation(gl.program, 'Ytex')
        gl.uniform1i(ySampler, 0)
        var uSampler = gl.getUniformLocation(gl.program, 'Utex')
        gl.uniform1i(uSampler, 1)
        var vSampler = gl.getUniformLocation(gl.program, 'Vtex')
        gl.uniform1i(vSampler, 2)
      }

      function createTexture (textureUnit) {
        var texture = gl.createTexture()
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1)
        gl.activeTexture(textureUnit)
        gl.bindTexture(gl.TEXTURE_2D, texture)
        // Set the parameters so we can render any size image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
        return texture
      }

      function updateShaders () {
        // 初始化数据, 每一行是一个顶点坐标和一个纹理坐标
        var verticesTexCoords = new Float32Array([
          -1, 1, 0.0, 1.0,
          -1, -1, 0.0, 0.0,
          1, 1, 1.0, 1.0,
          1, -1, 1.0, 0.0
        ])
        // 创建缓冲区对象
        var vertexTexCoordBuffer = gl.createBuffer()
        // 绑定缓冲区对象
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexCoordBuffer)
        // 将数据写入缓冲区对象
        gl.bufferData(gl.ARRAY_BUFFER, verticesTexCoords, gl.STATIC_DRAW)
        // 获取 attribute 变量的位置
        var a_Position = gl.getAttribLocation(gl.program, 'a_position')
        var a_TexCoord = gl.getAttribLocation(gl.program, 'a_texCoord')
        // 将缓冲区对象分配给 attribute 变量
        var FSIZE = verticesTexCoords.BYTES_PER_ELEMENT
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0)
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2)
        // 开启 attribute 变量
        gl.enableVertexAttribArray(a_Position)
        gl.enableVertexAttribArray(a_TexCoord)
      }

      function updateTextures (options) {
        var width = options.width
        var height = options.height
        updateTexture(gl.TEXTURE0, yTexture, options.y, width, height)
        updateTexture(gl.TEXTURE1, uTexture, options.u, width/2, height/2)
        updateTexture(gl.TEXTURE2, vTexture, options.v, width/2, height/2)
      }

      function updateTexture (textureUnit, texture, data, width, height) {
        gl.activeTexture(textureUnit)
        gl.bindTexture(gl.TEXTURE_2D, texture)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data)
        var e = gl.getError();
        if (e != gl.NO_ERROR) {
          console.log('upload yuv error', e);
        }
      }

      function renderImage (options) {
        if (options.width !== ctx.width ||
            options.height !== ctx.height ||
            options.rotation !== ctx.rotation) {
          initCanvas(options)
        }
        updateShaders(options)
        updateTextures(options)
        // 设置背景色
        gl.clearColor(0.0, 0.0, 0.0, 1.0)
        // 清空 canvas
        gl.clear(gl.COLOR_BUFFER_BIT)
        // 绘制
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
      }

      function drawImage (arrayBuffer) {
        window.yuv = arrayBuffer
        // slice yuv 数据
        // var width = 640
        // var height = 480
        var width = 512
        var height = 256
        var yLength = width * height
        var uLength = yLength / 4
        var vLength = yLength / 4
        if ((yLength + uLength + vLength) !== arrayBuffer.byteLength) {
          console.log('yuv数据长度不匹配')
          return
        }
        renderImage({
          width: width,
          height: height,
          y: new Uint8Array(arrayBuffer, 0, yLength),
          u: new Uint8Array(arrayBuffer, yLength, uLength),
          v: new Uint8Array(arrayBuffer, yLength + uLength)
        })
      }
      // 初始化 socket
      var url = 'ws://10.240.76.29:23432/'
      var socket = new WebSocket(url)
      socket.binaryType = 'arraybuffer'
      socket.onopen = function (event) {
        console.log('socket open', event)
      }
      socket.onclose = function (event) {
        console.log('socket close', event)
      }
      socket.onmessage = function (event) {
        console.log('socket msg', event)
        var data = event.data
        if (data instanceof ArrayBuffer) {
          drawImage(data)
        }
      }
      // 初始化按钮
      var count = 0
      var btn = document.querySelector('.btn')
      btn.addEventListener('click', function () {
        socket.send(count)
      })
    </script>
  </body>
</html>
